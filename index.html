<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>KALUA</title>
  <style media="screen">
  *{
    padding: 0;
    margin: 0;
    overflow: hidden;
  }
  </style>
</head>
<body>
<pre id="output"></pre>
</body>
</html>

<script type="text/javascript" src="js/three.js"></script>


<!-- <script src="//cdn.rawgit.com/mrdoob/three.js/master/build/three.min.js"></script> -->


<script type="text/javascript">


// LISTENER
document.onkeydown = function(e) {
  e = e || window.event;
  switch(e.which || e.keyCode) {

    case 37: // left
    mesh.skeleton.bones[3].scale.set(2, 1, 2);
    break;

    case 38: // up
    console.log("up");
    mesh.skeleton.bones[4].scale.set(1, 1, 1);
    break;

    case 39: // right
    mesh.skeleton.bones[3].scale.set(1, 1, 1);
    break;

    case 40: // down
    console.log("down");
    mesh.skeleton.bones[4].scale.set(2, 1, 2);
    break;

    case 32: // space
    console.log("space");
    break;
    default: return; // exit this handler for other keys
  }
  e.preventDefault(); // prevent the default action (scroll / move caret)
}


var camera, scene, renderer;
var geometry, material, mesh;
var mouse, raycaster;
var cubes = [];
init();
animate();

function init() {

  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
  camera.position.z = 1000;
  scene = new THREE.Scene();

  raycaster = new THREE.Raycaster();
	mouse = new THREE.Vector2();
  document.addEventListener( 'mousedown', onDocumentMouseDown, false );

  // instantiate a loader http://stackoverflow.com/q/20433474
  loader = new THREE.JSONLoader();
  loader.load('res/human2.json',function jsonReady( geometry ){
    mesh = new THREE.SkinnedMesh( geometry, new THREE.MeshNormalMaterial({skinning : true}) );
    // mesh = new THREE.SkinnedMesh( geometry, new  THREE.MeshLambertMaterial({color: 0xffffff, skinning : true}));
    mesh.scale.set( 50, 50, 50 );
    mesh.position.z = mesh.position.y = mesh.position.x = 0;
    mesh.translateY(-400);
    mesh.geometry.dynamic = true;
    scene.add( mesh );

    for (var i = 0; i < mesh.skeleton.bones.length; i++) {
      var cube = new THREE.Mesh( new THREE.CubeGeometry( 2, 2, 2 ), new THREE.MeshNormalMaterial({ transparent: true, opacity: 0}) );
      cube.name = mesh.skeleton.bones[i].name + "_cube";
      var bone_pos = mesh.skeleton.bones[i].position;
      cube.position.set( bone_pos.x, bone_pos.y, bone_pos.z );
      cubes.push(cube);
    }


    for (var i = 0; i < cubes.length; i++) {
      if (i != 0) {//dont render root bone
        mesh.add(cubes[i]);
      }
    }
    // adjust collider positions
    for (var i = 0; i < cubes.length; i++) {
        switch (cubes[i].name) {
          case "head_cube":
            cubes[i].position.y += 1;
            break;
          case "neck_cube":
            cubes[i].position.y += 1;
            break;
          case "chest_cube":
            cubes[i].position.y += 1;
            break;
          case "stomach_cube":
            cubes[i].position.y += 3;
            cubes[i].position.z -= 4;
            break;
          case "tight_r_cube":
            cubes[i].position.y -= 1;
            break;
          case "tight_l_cube":
            cubes[i].position.y -= 1;
            break;
          case "calve_r_cube":
            cubes[i].position.y -= 1;
            break;
          case "calve_l_cube":
            cubes[i].position.y -= 1;
            break;
          default:

        }
    }

    renderer.render(scene, camera);
  });

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);

  document.body.appendChild(renderer.domElement);

}


function animate() {
  requestAnimationFrame(animate);
  mesh.rotation.y += 0.01;

  renderer.render(scene, camera);
}

function onDocumentMouseDown( event ) {
				event.preventDefault();
				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( cubes );

        console.log(intersects[0].object.name);
			}







</script>
